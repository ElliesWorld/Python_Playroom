{
    "book_info": {
        "title": "C++ Programming Learning ",
        "version": "1.0.0",
        "description": "Complete guide to C++ programming concepts and modern features"
    },
    "chapters": [
        {
            "title": "C++ Fundamentals",
            "description": "Core C++ concepts and getting started",
            "pages": [
                {
                    "title": "What Makes C++ Special?",
                    "content": "<h2>‚ö° The Power of C++</h2><p>C++ is a compiled, statically-typed language that combines low-level control with high-level features. It's the backbone of operating systems, games, browsers, and high-performance applications.</p><h3>Key Strengths:</h3><ul><li><strong>Performance:</strong> Compiles to highly optimized machine code</li><li><strong>Control:</strong> Direct memory management and hardware access</li><li><strong>Object-Oriented:</strong> Classes, inheritance, polymorphism, encapsulation</li><li><strong>Generic Programming:</strong> Templates for type-safe, reusable code</li><li><strong>Standard Library:</strong> Rich STL with containers, algorithms, iterators</li></ul><h3>Used For:</h3><ul><li>Operating Systems (Windows, Linux kernels)</li><li>Game Engines (Unreal Engine, Unity backend)</li><li>Browsers (Chrome, Firefox)</li><li>Databases (MySQL, PostgreSQL)</li><li>Financial Trading Systems</li></ul><p><em>C++ gives you the tools to build anything from embedded systems to massive applications!</em></p>",
                    "category": "overview"
                },
                {
                    "title": "Setting Up Your First C++ Program",
                    "content": "<h2>üöÄ Hello, C++ World!</h2><p>Let's create your first C++ program with proper structure and modern practices:</p><h3>Basic Program Structure:</h3><pre><code>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>int main() {<br>    std::cout &lt;&lt; \"Welcome to C++!\" &lt;&lt; std::endl;<br>    <br>    std::string name;<br>    std::cout &lt;&lt; \"Enter your name: \";<br>    std::getline(std::cin, name);<br>    <br>    std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \"!\" &lt;&lt; std::endl;<br>    <br>    return 0;<br>}</code></pre><h3>Understanding the Parts:</h3><ul><li><strong>#include &lt;iostream&gt;:</strong> Standard input/output stream</li><li><strong>#include &lt;string&gt;:</strong> C++ string class</li><li><strong>std::cout:</strong> Standard output stream</li><li><strong>std::cin:</strong> Standard input stream</li><li><strong>std::endl:</strong> End line and flush buffer</li><li><strong>std::getline():</strong> Read entire line including spaces</li></ul><h3>Compilation:</h3><pre><code>g++ -o hello hello.cpp<br>./hello</code></pre><p><strong>Modern C++:</strong> Always use std:: prefix or 'using namespace std;' for standard library features!</p>",
                    "category": "basics"
                },
                {
                    "title": "Namespaces and Headers",
                    "content": "<h2>üóÇÔ∏è Organizing C++ Code</h2><p>C++ uses namespaces to avoid naming conflicts and headers to declare interfaces:</p><h3>Understanding std Namespace:</h3><pre><code>// Option 1: Use std:: prefix<br>#include &lt;iostream&gt;<br><br>int main() {<br>    std::cout &lt;&lt; \"Hello!\" &lt;&lt; std::endl;<br>    return 0;<br>}<br><br>// Option 2: Using declaration<br>#include &lt;iostream&gt;<br>using std::cout;<br>using std::endl;<br><br>int main() {<br>    cout &lt;&lt; \"Hello!\" &lt;&lt; endl;<br>    return 0;<br>}<br><br>// Option 3: Using directive (use sparingly)<br>#include &lt;iostream&gt;<br>using namespace std;<br><br>int main() {<br>    cout &lt;&lt; \"Hello!\" &lt;&lt; endl;<br>    return 0;<br>}</code></pre><h3>Common Headers:</h3><ul><li><strong>&lt;iostream&gt;:</strong> Input/output streams</li><li><strong>&lt;string&gt;:</strong> String class</li><li><strong>&lt;vector&gt;:</strong> Dynamic arrays</li><li><strong>&lt;algorithm&gt;:</strong> STL algorithms</li><li><strong>&lt;memory&gt;:</strong> Smart pointers</li><li><strong>&lt;fstream&gt;:</strong> File input/output</li></ul><h3>Creating Your Own Namespace:</h3><pre><code>namespace MyProject {<br>    void greet() {<br>        std::cout &lt;&lt; \"Hello from MyProject!\" &lt;&lt; std::endl;<br>    }<br>}<br><br>int main() {<br>    MyProject::greet();<br>    return 0;<br>}</code></pre>",
                    "category": "organization"
                }
            ]
        },
        {
            "title": "Types & Memory Management",
            "description": "C++ type system and memory handling",
            "pages": [
                {
                    "title": "Strong Type System",
                    "content": "<h2>üéØ C++ Type System</h2><p>C++ has a rich, static type system that catches errors at compile time:</p><h3>Fundamental Types:</h3><pre><code>// Integer types<br>int age = 25;              // Usually 32-bit<br>long long bigNumber = 1000000000000LL;<br>short temperature = -10;<br>unsigned int count = 100u;  // Only positive<br><br>// Floating point<br>float price = 19.99f;      // 32-bit precision<br>double pi = 3.14159265359; // 64-bit precision<br>long double precise = 3.14159265358979323846L;<br><br>// Character and boolean<br>char grade = 'A';<br>wchar_t unicode = L'‚Ç¨';    // Wide character<br>bool isActive = true;</code></pre><h3>Modern C++ Types (C++11+):</h3><pre><code>#include &lt;cstdint&gt;<br><br>// Fixed-width integers<br>std::int32_t id = 12345;   // Exactly 32 bits<br>std::uint64_t fileSize = 1024ULL;<br><br>// Type deduction<br>auto number = 42;          // int<br>auto price = 19.99;        // double<br>auto name = \"Jane\";        // const char*<br>auto message = std::string{\"Hello\"}; // std::string</code></pre><h3>Type Safety:</h3><pre><code>// C++ prevents dangerous conversions<br>int x = 3.14;     // Warning: truncation<br>bool flag = 42;   // Warning: implicit conversion<br><br>// Use explicit casts when needed<br>int y = static_cast&lt;int&gt;(3.14);<br>double z = static_cast&lt;double&gt;(x);</code></pre>",
                    "category": "types"
                },
                {
                    "title": "Stack vs Heap Memory",
                    "content": "<h2>üß† Memory Management in C++</h2><p>Understanding where your data lives is crucial for C++ programming:</p><h3>Stack Memory (Automatic):</h3><pre><code>void function() {<br>    int localVar = 42;        // Stack allocation<br>    char buffer[100];         // Stack array<br>    std::string text = \"Hi\";  // Object on stack<br>    <br>    // Automatically destroyed when function ends<br>}</code></pre><h3>Heap Memory (Dynamic):</h3><pre><code>// Raw pointers (avoid in modern C++)<br>int* ptr = new int(42);      // Heap allocation<br>delete ptr;                  // Must manually free<br>ptr = nullptr;               // Avoid dangling pointer<br><br>int* arr = new int[100];     // Heap array<br>delete[] arr;                // Array deletion<br><br>// Modern C++: Smart pointers (preferred)<br>#include &lt;memory&gt;<br><br>auto smartPtr = std::make_unique&lt;int&gt;(42);<br>auto sharedPtr = std::make_shared&lt;int&gt;(42);<br>// Automatically cleaned up!</code></pre><h3>RAII (Resource Acquisition Is Initialization):</h3><pre><code>class FileHandler {<br>private:<br>    std::FILE* file;<br>public:<br>    FileHandler(const char* filename) {<br>        file = std::fopen(filename, \"r\");<br>    }<br>    <br>    ~FileHandler() {           // Destructor<br>        if (file) std::fclose(file);<br>    }<br>    <br>    // Resource automatically managed<br>};</code></pre><h3>Best Practices:</h3><ul><li>Prefer stack allocation when possible</li><li>Use smart pointers instead of raw pointers</li><li>Follow RAII principles</li><li>Avoid memory leaks with proper cleanup</li></ul>",
                    "category": "memory"
                },
                {
                    "title": "References and Pointers",
                    "content": "<h2>üîó References vs Pointers</h2><p>C++ provides two ways to indirectly access objects: references and pointers:</p><h3>References (Aliases):</h3><pre><code>int original = 42;<br>int& ref = original;        // Reference to original<br><br>ref = 100;                  // Changes original to 100<br>std::cout &lt;&lt; original;       // Prints: 100<br><br>// References must be initialized<br>// int& badRef;             // Error!<br><br>// References cannot be reassigned<br>int other = 200;<br>ref = other;                // Changes value, not reference</code></pre><h3>Pointers (Memory Addresses):</h3><pre><code>int value = 42;<br>int* ptr = &amp;value;          // Pointer to value<br><br>std::cout &lt;&lt; ptr;            // Prints: memory address<br>std::cout &lt;&lt; *ptr;           // Prints: 42 (dereference)<br><br>*ptr = 100;                 // Changes value to 100<br><br>// Pointers can be null<br>int* nullPtr = nullptr;<br><br>// Pointers can be reassigned<br>int other = 200;<br>ptr = &amp;other;               // Now points to other</code></pre><h3>Function Parameters:</h3><pre><code>// Pass by value (copy)<br>void byValue(int x) {<br>    x = 100;  // Only changes local copy<br>}<br><br>// Pass by reference (alias)<br>void byReference(int&amp; x) {<br>    x = 100;  // Changes original<br>}<br><br>// Pass by pointer<br>void byPointer(int* x) {<br>    if (x) *x = 100;  // Changes original if not null<br>}<br><br>int main() {<br>    int num = 42;<br>    byValue(num);       // num still 42<br>    byReference(num);   // num now 100<br>    byPointer(&amp;num);    // num changes again<br>}</code></pre><h3>When to Use What:</h3><ul><li><strong>References:</strong> Function parameters, cleaner syntax</li><li><strong>Pointers:</strong> Optional parameters, dynamic allocation, data structures</li></ul>",
                    "category": "references"
                }
            ]
        },
        {
            "title": "Object-Oriented Programming",
            "description": "Classes, objects, and OOP principles in C++",
            "pages": [
                {
                    "title": "Classes and Objects",
                    "content": "<h2>üèóÔ∏è Building with Classes</h2><p>Classes are the foundation of object-oriented programming in C++. They encapsulate data and behavior together:</p><h3>Basic Class Definition:</h3><pre><code>class Student {<br>private:                    // Data hiding<br>    std::string name;<br>    int age;<br>    double gpa;<br><br>public:                     // Public interface<br>    // Constructor<br>    Student(const std::string&amp; n, int a, double g) <br>        : name(n), age(a), gpa(g) {}<br>    <br>    // Getter methods<br>    std::string getName() const { return name; }<br>    int getAge() const { return age; }<br>    double getGPA() const { return gpa; }<br>    <br>    // Setter methods<br>    void setAge(int newAge) {<br>        if (newAge &gt; 0) age = newAge;<br>    }<br>    <br>    // Methods<br>    void study() {<br>        std::cout &lt;&lt; name &lt;&lt; \" is studying!\" &lt;&lt; std::endl;<br>    }<br>    <br>    bool isHonorStudent() const {<br>        return gpa &gt;= 3.5;<br>    }<br>};</code></pre><h3>Using Objects:</h3><pre><code>int main() {<br>    // Create objects<br>    Student jane(\"Jane\", 20, 3.8);<br>    Student bob(\"Bob\", 19, 3.2);<br>    <br>    // Use methods<br>    jane.study();<br>    std::cout &lt;&lt; jane.getName() &lt;&lt; \" GPA: \" &lt;&lt; jane.getGPA();<br>    <br>    if (jane.isHonorStudent()) {<br>        std::cout &lt;&lt; \" - Honor Student!\" &lt;&lt; std::endl;<br>    }<br>    <br>    return 0;<br>}</code></pre><h3>Constructor Types:</h3><pre><code>class Point {<br>    double x, y;<br>public:<br>    // Default constructor<br>    Point() : x(0.0), y(0.0) {}<br>    <br>    // Parameterized constructor<br>    Point(double x, double y) : x(x), y(y) {}<br>    <br>    // Copy constructor<br>    Point(const Point&amp; other) : x(other.x), y(other.y) {}<br>};</code></pre>",
                    "category": "classes"
                },
                {
                    "title": "Inheritance and Polymorphism",
                    "content": "<h2>üå≥ Inheritance Hierarchies</h2><p>Inheritance allows you to create new classes based on existing ones, promoting code reuse and establishing \"is-a\" relationships:</p><h3>Basic Inheritance:</h3><pre><code>// Base class<br>class Animal {<br>protected:                  // Accessible to derived classes<br>    std::string name;<br>    int age;<br><br>public:<br>    Animal(const std::string&amp; n, int a) : name(n), age(a) {}<br>    <br>    virtual void makeSound() const {  // Virtual for polymorphism<br>        std::cout &lt;&lt; name &lt;&lt; \" makes a sound\" &lt;&lt; std::endl;<br>    }<br>    <br>    virtual ~Animal() = default;     // Virtual destructor<br>};<br><br>// Derived class<br>class Dog : public Animal {<br>private:<br>    std::string breed;<br><br>public:<br>    Dog(const std::string&amp; n, int a, const std::string&amp; b)<br>        : Animal(n, a), breed(b) {}   // Call base constructor<br>    <br>    void makeSound() const override { // Override base method<br>        std::cout &lt;&lt; name &lt;&lt; \" barks: Woof!\" &lt;&lt; std::endl;<br>    }<br>    <br>    void wagTail() const {            // Dog-specific method<br>        std::cout &lt;&lt; name &lt;&lt; \" wags tail happily!\" &lt;&lt; std::endl;<br>    }<br>};</code></pre><h3>Polymorphism in Action:</h3><pre><code>void petAnimal(const Animal&amp; pet) {<br>    pet.makeSound();  // Calls appropriate derived method<br>}<br><br>int main() {<br>    Dog buddy(\"Buddy\", 3, \"Golden Retriever\");<br>    Cat whiskers(\"Whiskers\", 2, \"Persian\");<br>    <br>    petAnimal(buddy);     // Calls Dog::makeSound()<br>    petAnimal(whiskers);  // Calls Cat::makeSound()<br>    <br>    // Using pointers for dynamic polymorphism<br>    std::vector&lt;std::unique_ptr&lt;Animal&gt;&gt; pets;<br>    pets.push_back(std::make_unique&lt;Dog&gt;(\"Rex\", 4, \"Labrador\"));<br>    pets.push_back(std::make_unique&lt;Cat&gt;(\"Luna\", 1, \"Siamese\"));<br>    <br>    for (const auto&amp; pet : pets) {<br>        pet-&gt;makeSound();  // Polymorphic call<br>    }<br>    <br>    return 0;<br>}</code></pre><h3>Access Specifiers:</h3><ul><li><strong>public:</strong> Accessible from anywhere</li><li><strong>protected:</strong> Accessible in derived classes</li><li><strong>private:</strong> Only accessible within the class</li></ul>",
                    "category": "inheritance"
                }
            ]
        },
        {
            "title": "STL and Modern C++",
            "description": "Standard Template Library and modern C++ features",
            "pages": [
                {
                    "title": "STL Containers",
                    "content": "<h2>üì¶ Standard Template Library</h2><p>The STL provides powerful, tested containers and algorithms that make C++ programming more efficient:</p><h3>Dynamic Arrays (std::vector):</h3><pre><code>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br><br>std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};<br><br>// Adding elements<br>numbers.push_back(6);         // Add to end<br>numbers.insert(numbers.begin(), 0); // Add to beginning<br><br>// Accessing elements<br>std::cout &lt;&lt; numbers[0];        // Direct access<br>std::cout &lt;&lt; numbers.at(1);     // Bounds-checked access<br><br>// Iterating<br>for (const auto&amp; num : numbers) {  // Range-based for (C++11)<br>    std::cout &lt;&lt; num &lt;&lt; \" \";<br>}<br><br>// STL algorithms<br>std::sort(numbers.begin(), numbers.end());<br>auto it = std::find(numbers.begin(), numbers.end(), 3);</code></pre><h3>Associative Containers:</h3><pre><code>#include &lt;map&gt;<br>#include &lt;unordered_map&gt;<br>#include &lt;set&gt;<br><br>// Map (key-value pairs, sorted)<br>std::map&lt;std::string, int&gt; scores;<br>scores[\"Jane\"] = 95;<br>scores[\"Bob\"] = 87;<br>scores.insert({\"Charlie\", 92});<br><br>// Hash map (faster lookups)<br>std::unordered_map&lt;int, std::string&gt; students;<br>students[101] = \"Jane Johnson\";<br>students[102] = \"Bob Smith\";<br><br>// Set (unique elements, sorted)<br>std::set&lt;std::string&gt; uniqueWords = {\"hello\", \"world\", \"hello\"};<br>// Only contains \"hello\" and \"world\"</code></pre><h3>Other Useful Containers:</h3><pre><code>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;deque&gt;<br><br>// Queue (FIFO)<br>std::queue&lt;std::string&gt; taskQueue;<br>taskQueue.push(\"Task 1\");<br>taskQueue.push(\"Task 2\");<br>std::string nextTask = taskQueue.front();<br>taskQueue.pop();<br><br>// Stack (LIFO)<br>std::stack&lt;int&gt; callStack;<br>callStack.push(1);<br>callStack.push(2);<br>int top = callStack.top();<br>callStack.pop();<br><br>// Deque (double-ended queue)<br>std::deque&lt;int&gt; flexibleArray;<br>flexibleArray.push_front(1);  // Add to front<br>flexibleArray.push_back(2);   // Add to back</code></pre>",
                    "category": "containers"
                },
                {
                    "title": "Modern C++ Features",
                    "content": "<h2>üöÄ Modern C++ (C++11 and Beyond)</h2><p>Modern C++ introduces features that make code safer, more expressive, and easier to maintain:</p><h3>Smart Pointers (C++11):</h3><pre><code>#include &lt;memory&gt;<br><br>// Unique ownership<br>auto ptr = std::make_unique&lt;int&gt;(42);<br>std::unique_ptr&lt;Student&gt; student = <br>    std::make_unique&lt;Student&gt;(\"Jane\", 20, 3.8);<br><br>// Shared ownership<br>auto shared1 = std::make_shared&lt;int&gt;(100);<br>auto shared2 = shared1;  // Both point to same object<br>// Object deleted when last shared_ptr goes out of scope</code></pre><h3>Lambda Expressions (C++11):</h3><pre><code>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br><br>std::vector&lt;int&gt; numbers = {5, 2, 8, 1, 9};<br><br>// Lambda function<br>auto isEven = [](int n) { return n % 2 == 0; };<br><br>// Using lambdas with STL algorithms<br>std::sort(numbers.begin(), numbers.end(), <br>          [](int a, int b) { return a &gt; b; }); // Descending sort<br><br>auto count = std::count_if(numbers.begin(), numbers.end(), isEven);<br><br>// Capture by value and reference<br>int multiplier = 3;<br>std::transform(numbers.begin(), numbers.end(), numbers.begin(),<br>               [multiplier](int n) { return n * multiplier; });</code></pre><h3>Range-Based For Loops (C++11):</h3><pre><code>std::vector&lt;std::string&gt; names = {\"Jane\", \"Bob\", \"Charlie\"};<br><br>// Traditional loop<br>for (size_t i = 0; i &lt; names.size(); ++i) {<br>    std::cout &lt;&lt; names[i] &lt;&lt; std::endl;<br>}<br><br>// Range-based for (much cleaner)<br>for (const auto&amp; name : names) {<br>    std::cout &lt;&lt; name &lt;&lt; std::endl;<br>}<br><br>// Modify elements<br>for (auto&amp; name : names) {<br>    name = \"Dr. \" + name;<br>}</code></pre><h3>Auto Type Deduction (C++11):</h3><pre><code>// Compiler deduces types<br>auto number = 42;                    // int<br>auto price = 19.99;                  // double<br>auto name = std::string{\"Jane\"};     // std::string<br>auto lambda = [](int x) { return x * 2; }; // lambda type<br><br>// Useful for complex types<br>auto it = std::find(numbers.begin(), numbers.end(), 5);<br>// Instead of: std::vector&lt;int&gt;::iterator it = ...</code></pre><h3>Move Semantics (C++11):</h3><pre><code>// Efficient transfer of resources<br>std::vector&lt;int&gt; createLargeVector() {<br>    std::vector&lt;int&gt; result(1000000, 42);<br>    return result;  // Move, not copy<br>}<br><br>auto vec = createLargeVector(); // Efficient move</code></pre>",
                    "category": "modern"
                }
            ]
        }
    ]
}